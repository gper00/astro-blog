---
title: "#5 Graph"
description: "Mengenal Graph sebagai struktur data paling fleksibel. Mempelajari representasi Adjacency Matrix dan Adjacency List di Java."
date: 2025-09-07
authors: ['umamalfarizi']
order: 5
---

Selamat datang di modul terakhir! Kita udah ngelewatin perjalanan panjang, dari data yang lurus, bercabang, dan sekarang kita sampai di bentuk yang paling bebas dan fleksibel: **Graph**.

Kalau Tree itu ibarat silsilah keluarga yang teratur, Graph itu ibarat jaringan pertemanan di media sosial. Nggak ada aturan `parent` atau `child` yang kaku. Setiap orang (kita sebut `Vertex` atau `Node`) bisa terhubung dengan siapa saja (hubungan ini kita sebut `Edge`). Contoh lain itu peta kota, di mana kota adalah vertex dan jalan adalah edge.

## Istilah Penting di Dunia Graph

Sebelum lanjut, ada beberapa istilah yang perlu kita tahu. Sebuah `Edge` (garis penghubung) bisa bersifat **undirected** (dua arah), kayak pertemanan di Facebook. Kalau kamu temenan sama B, berarti B juga temenan sama kamu. Tapi ada juga yang **directed** (satu arah), kayak follow di Twitter. Kamu follow artis A, belum tentu artis A follow kamu.

Selain itu, edge juga bisa punya `weight` (bobot). Misalnya dalam peta, bobot ini bisa berupa jarak antar kota.

## Cara Merepresentasikan Graph di Kode

Ini bagian yang paling penting. Gimana cara kita ngasih tau komputer soal hubungan antar vertex ini? Ada dua cara populer.

### 1. Adjacency Matrix (Matriks Ketetanggaan)

Bayangin kita punya tabel atau grid 2D. Baris dan kolomnya adalah semua vertex yang kita punya. Kalau ada hubungan dari vertex `i` ke vertex `j`, kita tandain `matrix[i][j]` dengan angka 1 (atau bobotnya). Kalau nggak ada, kita isi 0.

Cara ini cepet banget buat ngecek apakah dua vertex saling terhubung. Tapi boros memori, apalagi kalau vertex-nya banyak tapi hubungannya sedikit.

```java
// Contoh Adjacency Matrix untuk 4 vertex
int[][] matrix = {
    {0, 1, 0, 1}, // Vertex 0 terhubung ke 1 dan 3
    {1, 0, 1, 0}, // Vertex 1 terhubung ke 0 dan 2
    {0, 1, 0, 0}, // Vertex 2 terhubung ke 1
    {1, 0, 0, 0}  // Vertex 3 terhubung ke 0
};
```

### 2. Adjacency List (Daftar Ketetanggaan)

Ini cara yang paling umum dan lebih hemat memori. Idenya, kita punya daftar untuk setiap vertex. Nah, di dalam daftar itu, kita catet vertex mana aja yang terhubung sama dia.

Biasanya kita pakai `Map` atau `HashMap` di Java, di mana *key*-nya adalah vertex, dan *value*-nya adalah `List` dari tetangganya.

```java
import java.util.*;

class Graph {
    private Map<Integer, List<Integer>> adjacencyList;

    public Graph() {
        this.adjacencyList = new HashMap<>();
    }

    // Menambah vertex baru
    public void addVertex(int vertex) {
        adjacencyList.putIfAbsent(vertex, new ArrayList<>());
    }

    // Menambah edge (hubungan dua arah)
    public void addEdge(int v1, int v2) {
        adjacencyList.get(v1).add(v2);
        adjacencyList.get(v2).add(v1);
    }

    public void printGraph() {
        for (Integer vertex : adjacencyList.keySet()) {
            System.out.println("Vertex " + vertex + " terhubung dengan: " + adjacencyList.get(vertex));
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Graph graph = new Graph();
        graph.addVertex(0);
        graph.addVertex(1);
        graph.addVertex(2);
        graph.addVertex(3);

        graph.addEdge(0, 1);
        graph.addEdge(0, 3);
        graph.addEdge(1, 2);

        graph.printGraph();
    }
}
```

## Penutup Seri Pembelajaran

Luar biasa! Kita sudah sampai di akhir seri. Perjalanan kita dari `Linked List` yang sederhana, `Stack` & `Queue` yang berguna, `Sorting` & `Searching` yang fundamental, `Tree` yang terstruktur, hingga `Graph` yang super fleksibel, telah memberi kita fondasi yang kuat dalam dunia algoritma dan struktur data.

Konsep-konsep ini adalah inti dari pemecahan masalah dalam pemrograman. Dengan memahaminya, Anda tidak hanya bisa menulis kode, tapi juga merancang solusi yang efisien dan elegan.

Terima kasih sudah mengikuti seri ini. Teruslah berlatih, karena petualangan di dunia coding tidak pernah ada habisnya!
